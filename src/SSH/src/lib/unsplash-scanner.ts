import { promises as fs } from 'fs'
import path from 'path'

export interface UnsplashMatch {
  file: string
  line: number
  url: string
  context: string
}

export interface ScanResult {
  totalFiles: number
  scannedFiles: number
  matches: UnsplashMatch[]
  errors: string[]
}

/**
 * Utility to scan files for Unsplash image URLs
 */
export class UnsplashScanner {
  private unsplashPattern = /https?:\/\/images\.unsplash\.com\/[^\s"'`)]]+/gi
  private supportedExtensions = [
    '.js',
    '.jsx',
    '.ts',
    '.tsx',
    '.html',
    '.css',
    '.scss',
    '.sass',
    '.md',
    '.mdx',
    '.json',
  ]

  /**
   * Scan a directory recursively for Unsplash URLs
   */
  async scanDirectory(dirPath: string): Promise<ScanResult> {
    const result: ScanResult = {
      totalFiles: 0,
      scannedFiles: 0,
      matches: [],
      errors: [],
    }

    try {
      await this.scanDirectoryRecursive(dirPath, result)
    } catch (error) {
      result.errors.push(
        `Error scanning directory: ${error instanceof Error ? error.message : 'Unknown error'}`,
      )
    }

    return result
  }

  /**
   * Scan a single file for Unsplash URLs
   */
  async scanFile(filePath: string): Promise<UnsplashMatch[]> {
    const matches: UnsplashMatch[] = []

    try {
      const content = await fs.readFile(filePath, 'utf-8')
      const lines = content.split('\n')

      lines.forEach((line, index) => {
        const urlMatches = line.match(this.unsplashPattern)
        if (urlMatches) {
          urlMatches.forEach((url) => {
            matches.push({
              file: filePath,
              line: index + 1,
              url,
              context: line.trim(),
            })
          })
        }
      })
    } catch {
      // Silently skip files that can't be read
    }

    return matches
  }

  /**
   * Generate migration report
   */
  generateReport(scanResult: ScanResult): string {
    const { totalFiles, scannedFiles, matches, errors } = scanResult

    let report = '# Unsplash Migration Report\n\n'
    report += `**Scan Summary:**\n`
    report += `- Total files found: ${totalFiles}\n`
    report += `- Files scanned: ${scannedFiles}\n`
    report += `- Unsplash URLs found: ${matches.length}\n`
    report += `- Errors: ${errors.length}\n\n`

    if (matches.length > 0) {
      report += '## Unsplash URLs Found\n\n'

      // Group by file
      const fileGroups = this.groupMatchesByFile(matches)

      Object.entries(fileGroups).forEach(([file, fileMatches]) => {
        report += `### ${file}\n\n`
        fileMatches.forEach((match) => {
          report += `**Line ${match.line}:**\n`
          report += `\`\`\`\n${match.context}\n\`\`\`\n`
          report += `URL: \`${match.url}\`\n\n`
        })
      })

      report += '## Unique URLs\n\n'
      const uniqueUrls = [...new Set(matches.map((m) => m.url))]
      uniqueUrls.forEach((url) => {
        report += `- \`${url}\`\n`
      })
      report += '\n'

      report += '## Migration Recommendations\n\n'
      report +=
        '1. **Download Images**: Use the URLs above to download images to your local media library\n'
      report +=
        '2. **Upload to Media Management**: Use the media management system to upload and organize these images\n'
      report +=
        '3. **Update References**: Replace Unsplash URLs with references to your local media files\n'
      report +=
        '4. **Add Metadata**: Use the media management system to add proper titles, alt text, and descriptions\n'
      report +=
        '5. **Enable Watermarking**: Apply your eYogi Gurukul watermarks to the downloaded images\n\n'
    }

    if (errors.length > 0) {
      report += '## Errors\n\n'
      errors.forEach((error) => {
        report += `- ${error}\n`
      })
      report += '\n'
    }

    report += '---\n'
    report += `Report generated on ${new Date().toLocaleString()}\n`

    return report
  }

  /**
   * Export matches as CSV
   */
  generateCSV(matches: UnsplashMatch[]): string {
    let csv = 'File,Line,URL,Context\n'

    matches.forEach((match) => {
      const escapedContext = match.context.replace(/"/g, '""')
      csv += `"${match.file}",${match.line},"${match.url}","${escapedContext}"\n`
    })

    return csv
  }

  /**
   * Get download script for all URLs
   */
  generateDownloadScript(matches: UnsplashMatch[]): string {
    const uniqueUrls = [...new Set(matches.map((m) => m.url))]

    let script = '#!/bin/bash\n\n'
    script += '# Unsplash Image Download Script\n'
    script += '# Generated by eYogi Media Scanner\n\n'
    script += 'mkdir -p unsplash_downloads\ncd unsplash_downloads\n\n'

    uniqueUrls.forEach((url, index) => {
      const filename = this.generateFilenameFromUrl(url, index)
      script += `echo "Downloading ${filename}..."\n`
      script += `curl -L "${url}" -o "${filename}"\n`
      script += `sleep 1  # Be respectful to Unsplash servers\n\n`
    })

    script += 'echo "Download complete!"\n'
    script += 'echo "Files downloaded to: $(pwd)"\n'

    return script
  }

  private async scanDirectoryRecursive(dirPath: string, result: ScanResult): Promise<void> {
    try {
      const entries = await fs.readdir(dirPath, { withFileTypes: true })

      for (const entry of entries) {
        const fullPath = path.join(dirPath, entry.name)

        // Skip node_modules, .git, and other common directories
        if (entry.isDirectory()) {
          if (!this.shouldSkipDirectory(entry.name)) {
            await this.scanDirectoryRecursive(fullPath, result)
          }
          continue
        }

        result.totalFiles++

        if (this.shouldScanFile(entry.name)) {
          try {
            const matches = await this.scanFile(fullPath)
            result.matches.push(...matches)
            result.scannedFiles++
          } catch (error) {
            result.errors.push(
              `Error scanning ${fullPath}: ${error instanceof Error ? error.message : 'Unknown error'}`,
            )
          }
        }
      }
    } catch (error) {
      result.errors.push(
        `Error reading directory ${dirPath}: ${error instanceof Error ? error.message : 'Unknown error'}`,
      )
    }
  }

  private shouldSkipDirectory(name: string): boolean {
    const skipDirs = [
      'node_modules',
      '.git',
      '.next',
      '.nuxt',
      'dist',
      'build',
      '.cache',
      'coverage',
      '.nyc_output',
      'logs',
      '*.log',
    ]

    return skipDirs.some((skip) => name.includes(skip))
  }

  private shouldScanFile(filename: string): boolean {
    return this.supportedExtensions.some((ext) => filename.endsWith(ext))
  }

  private groupMatchesByFile(matches: UnsplashMatch[]): Record<string, UnsplashMatch[]> {
    return matches.reduce(
      (groups, match) => {
        if (!groups[match.file]) {
          groups[match.file] = []
        }
        groups[match.file].push(match)
        return groups
      },
      {} as Record<string, UnsplashMatch[]>,
    )
  }

  private generateFilenameFromUrl(url: string, index: number): string {
    try {
      // Extract image ID from Unsplash URL
      const match = url.match(/\/photo-(\w+)/)
      if (match) {
        return `unsplash_${match[1]}.jpg`
      }

      // Fallback to index-based naming
      return `unsplash_image_${index + 1}.jpg`
    } catch {
      return `unsplash_image_${index + 1}.jpg`
    }
  }
}

/**
 * CLI-style function for direct usage
 */
export async function scanForUnsplashUrls(
  scanPath: string,
  outputPath?: string,
): Promise<ScanResult> {
  const scanner = new UnsplashScanner()
  const result = await scanner.scanDirectory(scanPath)

  if (outputPath) {
    try {
      const report = scanner.generateReport(result)
      await fs.writeFile(path.join(outputPath, 'unsplash-report.md'), report, 'utf-8')

      if (result.matches.length > 0) {
        const csv = scanner.generateCSV(result.matches)
        await fs.writeFile(path.join(outputPath, 'unsplash-urls.csv'), csv, 'utf-8')

        const script = scanner.generateDownloadScript(result.matches)
        await fs.writeFile(path.join(outputPath, 'download-unsplash.sh'), script, 'utf-8')
      }

      console.log(`Reports generated in: ${outputPath}`)
    } catch (error) {
      console.error('Error writing reports:', error)
    }
  }

  return result
}

// Example usage for scanning the SSH folder
export async function scanSSHFolder(): Promise<ScanResult> {
  const sshPath = path.join(process.cwd(), 'src', 'SSH')
  const outputPath = path.join(process.cwd(), 'migration-reports')

  // Ensure output directory exists
  try {
    await fs.mkdir(outputPath, { recursive: true })
  } catch {
    // Directory might already exist
  }

  return scanForUnsplashUrls(sshPath, outputPath)
}
